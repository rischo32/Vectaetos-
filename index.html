<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<title>Vectaetos — Noetické Epistemické Pole</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
html, body {
  margin: 0; padding: 0;
  width: 100%; height: 100%;
  background: #000;
  overflow: hidden;
  font-family: system-ui, sans-serif;
}
canvas { position: fixed; inset: 0; z-index: 1; }
#askField {
  position: fixed; bottom: 24px; left: 50%;
  transform: translateX(-50%);
  width: 80%; max-width: 420px;
  padding: 10px 12px;
  background: rgba(255,255,255,0.07);
  border: none; outline: none;
  color: #eee; font-size: 14px;
  border-radius: 4px;
  z-index: 3;
  pointer-events: all;
}
#hint {
  position: fixed; bottom: 8px; left: 50%;
  transform: translateX(-50%);
  color: #bbb; font-size: 11px;
  text-align: center; opacity: 0.6;
  pointer-events: none;
  z-index: 3;
}
</style>
</head>
<body>

<input id="askField" placeholder="Ask into the field and press Enter..." />
<div id="hint">Your question becomes impulse, not answer.</div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/shaders/CopyShader.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/postprocessing/ShaderPass.js"></script>

<script>
// ---------- BASIC RENDERER + SCENE ----------
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.018);

const camera = new THREE.PerspectiveCamera(
  50, window.innerWidth/window.innerHeight, 0.1, 1000
);
camera.position.z = 18;

// Renderer
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

// ---------- BLOOM POSTPROCESSING ----------
const composer = new THREE.EffectComposer(renderer);
const renderPass = new THREE.RenderPass(scene, camera);
composer.addPass(renderPass);

const bloomPass = new THREE.UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight),
  0.9, 0.5, 0.8
);
bloomPass.threshold = 0.15;
bloomPass.strength = 0.75;
bloomPass.radius = 0.4;
composer.addPass(bloomPass);

// ---------- NEBULA BACKGROUND SHADER ----------
const nebulaGeo = new THREE.SphereGeometry(80, 32, 32);
const nebulaMat = new THREE.ShaderMaterial({
  side: THREE.BackSide,
  uniforms: {
    time: { value: 0.0 }
  },
  vertexShader: `
    varying vec3 vPos;
    void main(){
      vPos = position;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.);
    }
  `,
  fragmentShader: `
    uniform float time;
    varying vec3 vPos;
    void main(){
      float intensity = pow(0.6 - dot(normalize(vPos), vec3(0.0,0.0,1.0)), 3.4);
      float noise = sin(dot(vPos.xy * 4.0, vec2(12.9898,78.233)) + time*0.12);
      gl_FragColor = vec4(0.05 + intensity*0.08 + noise*0.02, 0.02, 0.05 + noise*0.015, 1.0);
    }
  `
});
scene.add(new THREE.Mesh(nebulaGeo, nebulaMat));

// ---------- NODE + RUNIC DYNAMICS ----------
const nodeData = [
  { c:0xff5555, p:[7,0,0] },
  { c:0xffb300, p:[4,5,1] },
  { c:0x33ccff, p:[-4,5,-1] },
  { c:0x6aff66, p:[-7,1,3] },
  { c:0xaa66ff, p:[-5,-4,-2] },
  { c:0xff4444, p:[0,-7,1] },
  { c:0xff44aa, p:[5,-4,1] },
  { c:0xff9000, p:[0,0,7] }
];

let nodes = [], nodeStates = [];
const baseGeom = new THREE.IcosahedronGeometry(0.45,1);

nodeData.forEach((o,i)=>{
  let mat = new THREE.MeshStandardMaterial({
    color:o.c, emissive:o.c, emissiveIntensity:0.2,
    metalness:0.3, roughness:0.35
  });
  let m = new THREE.Mesh(baseGeom, mat);
  m.position.set(...o.p);
  scene.add(m);
  nodes.push(m);
  nodeStates.push(i % 4);
});

// Ambient lighting + dynamic node lights
scene.add(new THREE.AmbientLight(0xffffff, 0.25));
nodes.forEach(n=>{
  let l = new THREE.PointLight(n.material.color, 0.7, 30);
  l.position.copy(n.position);
  scene.add(l);
});

// Dynamic curved lines between nodes
function makeCurve(a,b){
  let pts=[a.clone(),
    new THREE.Vector3().addVectors(a,b).multiplyScalar(0.5).add(new THREE.Vector3(0,1,0)),
    b.clone()];
  let curve = new THREE.CatmullRomCurve3(pts);
  let geo = new THREE.BufferGeometry().setFromPoints(curve.getPoints(50));
  let mat = new THREE.LineBasicMaterial({ color: 0x222222, transparent:true, opacity:0.15 });
  return new THREE.Line(geo, mat);
}
nodes.forEach((n,i)=>{
  for(let j=i+1; j<nodes.length; j++){
    scene.add(makeCurve(n.position, nodes[j].position));
  }
});

// Runic phase effect
function applyPhase(n, st, t, impulse){
  const base = 0.18;
  if(st===0){
    n.material.emissiveIntensity = base + Math.sin(t*1.2)*0.02*(1+impulse);
    n.scale.setScalar(1 + Math.sin(t*0.8)*0.02);
  }
  if(st===1){
    n.material.emissiveIntensity = base + 0.11 + Math.sin(t*1.8)*0.04*(1+impulse);
    n.scale.setScalar(1 + Math.sin(t*1.0)*0.03);
  }
  if(st===2){
    n.material.emissiveIntensity = base + 0.23 + Math.sin(t*2.4)*0.06*(1+impulse);
    n.scale.setScalar(1 + Math.sin(t*1.3)*0.05);
  }
  if(st===3){
    let fade = abs(sin(t*0.6));
    n.material.emissiveIntensity = (base + 0.04)*fade*(1+impulse);
    n.scale.setScalar(0.85 + fade*0.08);
  }
}

// Interaction impulse
let impulse=0;
document.getElementById("askField").addEventListener("keydown", e=>{
  if(e.key==="Enter"){
    e.preventDefault();
    impulse=1.0;
    document.getElementById("askField").value="";
  }
});

// Animate loop
let time=0;
function animate(){
  time += 0.0021;
  nebulaMat.uniforms.time.value = time;

  nodes.forEach((n,i)=>{
    applyPhase(n,nodeStates[i],time,impulse);
    n.position.x += Math.sin(time+i*1.1)*0.0012;
    n.position.y += Math.cos(time+i*1.3)*0.0012;
  });

  if(impulse>0) impulse -= 0.02;

  camera.position.x = Math.sin(time*0.24)*14*(1+impulse*0.15);
  camera.position.y = Math.cos(time*0.18)*9*(1+impulse*0.15);
  camera.lookAt(scene.position);

  composer.render();
  requestAnimationFrame(animate);
}
animate();

// Resize
window.addEventListener("resize",()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  composer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
