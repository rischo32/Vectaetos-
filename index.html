<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Φ</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
body{
  margin:0;
  background:#05070a;
  font-family:system-ui,-apple-system,BlinkMacSystemFont,sans-serif;
  overflow:hidden;
}
.top{
  position:absolute;
  top:20px;
  width:100%;
  text-align:center;
  font-size:32px;
  color:#e0e0e0;
}
.bottom{
  position:absolute;
  bottom:20px;
  width:100%;
  text-align:center;
  font-size:14px;
}
.bottom a{
  color:#888;
  text-decoration:none;
  margin:0 10px;
}
.bottom a:hover{ color:#fff; }
</style>
</head>
<body>

<div class="top">Φ</div>
<div class="bottom">
  <a href="https://github.com/rischo32/Vectaetos" target="_blank">Repository</a> |
  <a href="https://zenodo.org/records/18395048" target="_blank">DOI</a>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
<script>

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.z = 4;

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

// axiomatické farby
const COLORS = [
  0x666666, // INT
  0xf1c40f, // LEX
  0x00bcd4, // VER
  0x3498db, // LIB
  0xff9800, // UNI
  0x4caf50, // REL
  0xf44336, // WIS
  0x9c27b0  // CRE
];

// 8 bodov na sfére (geometrická symetria)
const radius = 1.5;
const nodes = [];
const nodeGroup = new THREE.Group();

for(let i=0;i<8;i++){
  const phi = Math.acos(-1 + (2*i)/8);
  const theta = Math.sqrt(8*Math.PI) * phi;

  const x = radius * Math.cos(theta) * Math.sin(phi);
  const y = radius * Math.sin(theta) * Math.sin(phi);
  const z = radius * Math.cos(phi);

  const geo = new THREE.SphereGeometry(0.08,16,16);
  const mat = new THREE.MeshBasicMaterial({color:COLORS[i]});
  const mesh = new THREE.Mesh(geo,mat);
  mesh.position.set(x,y,z);

  nodeGroup.add(mesh);
  nodes.push(mesh.position.clone());
}

scene.add(nodeGroup);

// hrany (symetrické)
const edgeGroup = new THREE.Group();
scene.add(edgeGroup);

for(let i=0;i<nodes.length;i++){
  for(let j=i+1;j<nodes.length;j++){

    const geometry = new THREE.BufferGeometry().setFromPoints([
      nodes[i],
      nodes[j]
    ]);

    const material = new THREE.LineBasicMaterial({
      color: COLORS[i],
      transparent:true,
      opacity:0.5
    });

    const line = new THREE.Line(geometry,material);
    edgeGroup.add(line);
  }
}

let t = 0;

function animate(){
  requestAnimationFrame(animate);
  t += 0.003;

  // pomalá rotácia
  nodeGroup.rotation.y += 0.002;
  nodeGroup.rotation.x += 0.001;

  edgeGroup.rotation.copy(nodeGroup.rotation);

  // jemné plávanie
  nodeGroup.position.y = Math.sin(t)*0.15;
  edgeGroup.position.y = nodeGroup.position.y;

  renderer.render(scene,camera);
}

animate();

window.addEventListener('resize',()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});

</script>
</body>
</html>
