<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vortex — Epistemic Field</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #0C0D10;
      font-family: Inter, sans-serif;
    }

    canvas {
      display: block;
    }
  </style>
</head>
<body>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

/* ----------------------------------------
   BASIC SCENE SETUP
-----------------------------------------*/

const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  0.1,
  100
);

camera.position.set(1.4, 0.9, 1.4);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setClearColor(0x0C0D10, 1);

document.body.appendChild(renderer.domElement);

/* ----------------------------------------
   AXES (W=X, H=Y, D=Z)
-----------------------------------------*/

function createAxis(color, start, end) {
  const material = new THREE.LineBasicMaterial({ color });
  const points = [start, end];
  const geometry = new THREE.BufferGeometry().setFromPoints(points);
  return new THREE.Line(geometry, material);
}

const axisLength = 1.2;

// W (X axis)
scene.add(createAxis(0x444444,
  new THREE.Vector3(-axisLength, 0, 0),
  new THREE.Vector3(axisLength, 0, 0)
));

// H (Y axis)
scene.add(createAxis(0x444444,
  new THREE.Vector3(0, -axisLength, 0),
  new THREE.Vector3(0, axisLength, 0)
));

// D (Z axis)
scene.add(createAxis(0x444444,
  new THREE.Vector3(0, 0, -axisLength),
  new THREE.Vector3(0, 0, axisLength)
));

  /* ----------------------------------------
   3D GRID
-----------------------------------------*/

const gridColor = 0x222222;

const gridXY = new THREE.GridHelper(2, 20, gridColor, gridColor);
gridXY.rotation.x = Math.PI / 2;
scene.add(gridXY);

const gridXZ = new THREE.GridHelper(2, 20, gridColor, gridColor);
scene.add(gridXZ);

const gridYZ = new THREE.GridHelper(2, 20, gridColor, gridColor);
gridYZ.rotation.z = Math.PI / 2;
scene.add(gridYZ);

// zníženie opacity
[gridXY, gridXZ, gridYZ].forEach(g => {
  g.material.opacity = 0.08;
  g.material.transparent = true;
});
  
/* ----------------------------------------
   EPISTEMIC POINT
-----------------------------------------*/

const pointGeometry = new THREE.SphereGeometry(0.035, 32, 32);
const pointMaterial = new THREE.MeshBasicMaterial({ color: 0x5DA9FF });
const point = new THREE.Mesh(pointGeometry, pointMaterial);

scene.add(point);

/* ----------------------------------------
   CAMERA MICRO ORBIT
-----------------------------------------*/

let time = 0;

function animate() {
  requestAnimationFrame(animate);

  time += 0.003;

  const radius = 1.8;
  const x = Math.cos(time) * radius;
  const z = Math.sin(time) * radius;
  const y = 0.9 + Math.sin(time * 0.5) * 0.05;

  camera.position.set(1,8, 1,2, 1,8);
  camera.lookAt(0, 0, 0);

  renderer.render(scene, camera);
}

animate();

/* ----------------------------------------
   RESPONSIVE
-----------------------------------------*/

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
