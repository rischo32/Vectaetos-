<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Vortex â€” Epistemic Field</title>

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #0C0D10;
    font-family: -apple-system, BlinkMacSystemFont, sans-serif;
  }

  #ui {
    position: absolute;
    bottom: 40px;
    left: 50%;
    transform: translateX(-50%);
    width: 420px;
    text-align: center;
    pointer-events: none;
  }

  textarea {
    width: 100%;
    height: 80px;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
    color: #fff;
    padding: 12px;
    resize: none;
    border-radius: 14px;
    outline: none;
    pointer-events: all;
  }

  #buffer {
    margin-top: 8px;
    height: 4px;
    background: rgba(255,255,255,0.08);
    border-radius: 4px;
    overflow: hidden;
  }

  #bufferFill {
    height: 100%;
    width: 0%;
    background: #5DA9FF;
    transition: width 0.1s ease;
  }
</style>
</head>

<body>

<div id="ui">
  <textarea id="question" maxlength="100" placeholder="Type your question..."></textarea>
  <div id="buffer">
    <div id="bufferFill"></div>
  </div>
</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

/* =========================
   BASIC SCENE
========================= */

const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  65,
  window.innerWidth / window.innerHeight,
  0.1,
  100
);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setClearColor(0x0C0D10, 1);
document.body.appendChild(renderer.domElement);

/* =========================
   LIGHT
========================= */

scene.add(new THREE.AmbientLight(0xffffff, 0.4));

const dir = new THREE.DirectionalLight(0xffffff, 0.3);
dir.position.set(2,3,2);
scene.add(dir);

/* =========================
   AXES
========================= */

function axis(start, end) {
  const material = new THREE.LineBasicMaterial({ color: 0x333333 });
  const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
  return new THREE.Line(geometry, material);
}

const axisLength = 1.5;

scene.add(axis(
  new THREE.Vector3(-axisLength,0,0),
  new THREE.Vector3(axisLength,0,0)
));

scene.add(axis(
  new THREE.Vector3(0,-axisLength,0),
  new THREE.Vector3(0,axisLength,0)
));

scene.add(axis(
  new THREE.Vector3(0,0,-axisLength),
  new THREE.Vector3(0,0,axisLength)
));

/* =========================
   GRID
========================= */

const grid = new THREE.GridHelper(3,30,0x222222,0x222222);
grid.material.opacity = 0.08;
grid.material.transparent = true;
scene.add(grid);

/* =========================
   EM POINT
========================= */

const baseHue = 210 / 360;

const emGeometry = new THREE.SphereGeometry(0.04, 32, 32);
const emMaterial = new THREE.MeshStandardMaterial({
  color: 0x5DA9FF,
  emissive: 0x5DA9FF,
  emissiveIntensity: 0.6
});
let emPoint = new THREE.Mesh(emGeometry, emMaterial);
scene.add(emPoint);

/* =========================
   CAMERA ORBIT
========================= */

let time = 0;
const radius = 2.2;

/* =========================
   INPUT LOGIC
========================= */

const textarea = document.getElementById("question");
const bufferFill = document.getElementById("bufferFill");

let intensity = 0;
let splitting = false;
let splitProgress = 0;
let gatePoints = [];
let targetPositions = [];

textarea.addEventListener("input", () => {
  const length = textarea.value.length;
  intensity = length / 100;
  bufferFill.style.width = (intensity * 100) + "%";
});

textarea.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    e.preventDefault();
    if (!splitting) startSplit();
  }
});

/* =========================
   SIGMA HEURISTIC
========================= */

function computeSigma(text) {
  const length = text.length;
  const words = text.split(" ").length;

  const W = Math.min(1, words / 12);
  const H = Math.min(1, text.includes("?") ? 0.8 : 0.4);
  const D = Math.min(1, length / 100);

  return { W, H, D };
}

/* =========================
   SPLIT
========================= */

function startSplit() {
  splitting = true;
  splitProgress = 0;

  const { W, H, D } = computeSigma(textarea.value);
  const I = intensity;

  targetPositions = [
    new THREE.Vector3(W * I * axisLength, 0, 0),
    new THREE.Vector3(0, H * I * axisLength, 0),
    new THREE.Vector3(0, 0, D * I * axisLength)
  ];

  const colors = [
    new THREE.Color().setHSL(baseHue - 0.03, 0.8, 0.4 + W * 0.3),
    new THREE.Color().setHSL(baseHue + 0.05, 0.8, 0.4 + H * 0.3),
    new THREE.Color().setHSL(baseHue - 0.1, 0.8, 0.4 + D * 0.3)
  ];

  for (let i = 0; i < 3; i++) {
    const g = new THREE.SphereGeometry(0.035, 24, 24);
    const m = new THREE.MeshStandardMaterial({
      color: colors[i],
      emissive: colors[i],
      emissiveIntensity: 0.6
    });
    const mesh = new THREE.Mesh(g, m);
    scene.add(mesh);
    gatePoints.push(mesh);
  }

  scene.remove(emPoint);
}

/* =========================
   ANIMATION LOOP
========================= */

function animate() {
  requestAnimationFrame(animate);
  time += 0.002;

  camera.position.set(
    Math.cos(time)*radius,
    1.2 + Math.sin(time*0.5)*0.1,
    Math.sin(time)*radius
  );
  camera.lookAt(0,0,0);

  if (!splitting && emPoint) {
    const scale = 1 + intensity * 0.8 + Math.sin(time*10)*0.05;
    emPoint.scale.set(scale, scale, scale);

    emPoint.position.x = Math.sin(time*3) * intensity * 0.3;
    emPoint.position.y = Math.cos(time*2) * intensity * 0.2;
    emPoint.position.z = Math.sin(time*4) * intensity * 0.3;
  }

  if (splitting && splitProgress < 1) {
    splitProgress += 0.02;

    const eased = splitProgress < 0.5
      ? 2 * splitProgress * splitProgress
      : 1 - Math.pow(-2 * splitProgress + 2, 2) / 2;

    for (let i = 0; i < gatePoints.length; i++) {
      gatePoints[i].position.lerpVectors(
        new THREE.Vector3(0,0,0),
        targetPositions[i],
        eased
      );
    }
  }

  renderer.render(scene, camera);
}

animate();

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
